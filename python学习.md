# Python 语言

## Python 开发环境

###  计算机组成

![1563166342399](C:\Users\89463\AppData\Roaming\Typora\typora-user-images\1563166342399.png)

编程语言(计算机语言)是人们为了控制计算机,而设计的一种符号和文字的组合,从而实现向计算机发出指令.

- 形式是符号和文字的组合
- 目的是为了控制计算机硬件

Python 语言就是一种编程语言,由符号和文字组成的,使用Python 语言的目的就是为了控制计算机硬件进行工作

#### 1.2.2 解释器

将文字和符号转换为机器指令,这个负责转换的去恶色叫做解释器解释器本质上就是一个运行在操作系统上的程序

![1563167314873](C:\Users\89463\AppData\Roaming\Typora\typora-user-images\1563167314873.png)

解析器负责翻译编程语言

1. 知道编程语言的作用

2. 知道编程语言和解析器之间的关系
3. 知道Python解释器种类
4. 知道解释器和操作系统的关系

#### 环境搭建

Python 包含两个部分

编辑器和解释器



PyCahrm (IDE)

Python 的作者,Gruido von Rossum 吉多,范,罗苏姆,龟叔.荷兰人,

1991年诞生,由C语言实现

Python 由两个版本,Python2和Python3,最新版本分别为2.7.15和3.6.5

版本根据anaconda使用?

##### 注释

 #单行注释

""" 多行注释  """

##### 变量

变量会申请一块内存 10,变量存储需要的临时数据

a =10 重建一个新的变量,并且赋值操作

a=100 重新赋值

注释快捷键 ctrl+ /

变量是用来临时存储程序运行中所需要的一些数据的

数据类型

 - 数字型
    - 整数型
    - 小数型

- 布尔类型bool

- 字符串str 文本型

type(参数) 函数用来检查相应的

python 里面定义变量不需要指定类型,根据赋的值来推断变量模型

##### 算术预算符

```
+ 
- 
* 
/
//整除 (商) 返回除法的整数部分 9//2=4
% 取余数 9%2=1
** 幂 次方 2**3 = 8
```

##### 符合赋值运算符

> 字符串和数字之间不能进行加减运算,但可以相乘,相当于复制

##### 格式化输出联系

```python
print("我的名字叫 %s ,请多多关照" % name)
print("学号是%06d"% student_no)
print("苹果单价 %.02f 元/斤,购买 %.02f 斤,需要支付 %.02f 元"%(price,weight,money))
苹果单价9.00元/斤,购买了5.00斤,需要支付45.00元
print("数据比例是%.02f%%"%(scale*100))
```

##### 键盘输入

input_content = input("请输入您的名字")

print('欢迎您 %s !'%intput_content)

##### 变量的类型转换

int(val),将变量val 转换为 int 类型

float(val),str(val)

##### if语句

```
if 3>2:
    print()
elif 3<2:
    print()
else:
    print()
```

while 循环 continue 跳过,break退出循环

while 可嵌套循环

##### 函数

def 函数名(a,b,c)

​	函数体

​	return

##### 容器

##### 字符串截取

字符串提供了一种语法,用来获取

user_email ="simagousheng@itcast.cn"

print(user_email[0])

print(user_email[0:4])

print(user_email[0:12])

##### 获得容器元素的个数

string_length = len(user_email)

print(user_email[13:string_length])

起始值不写表示从0开始

结束值不写表示到最后

**步长**

最后一个参数值,表示间隔多少取一个数

user_email[0:12:2] = smguhn

user_email[-5:-1]=st.cn   

-1从末端数起第一位:

user_email[6:1:-1]

字符串逆序:

user_email[::-1]

#### str.find(参数)函数

```python
position = user_email.find('@')
int position == -1:
	print('@不存在,邮箱不合法!')
else:
	print('@的位置是:',position)
```

#### .split(参数):分片

拆分成['aa','bb','cc','dd']

#### .count(参数):判断有多少个char

#### .strip() :去除两头空格

username = "    asdasd    "

new_username = username.strip()

print(username)  原字符变量不会修改  **结果不变**

print(new_username) 结果去除了两头的空格

#### ctrl+q :函数文档

#### 函数:单一职责原则



### 容器概述

![1563242582121](C:\Users\89463\AppData\Roaming\Typora\typora-user-images\1563242582121.png)

1. 序列式容器中的元素在存放时都是连续存放的,包括**字符串,列表,元组.**
2. 非序列式容器在存储元素时不是连续存放的,包括**字典,集合**

**序列式容器支持根据下表存期元素**

##### 字符串遍历

```python
my_str = 'hello'
for abc in my_str:
    print(abc)
```

##### 字符串替换 str.replace('妮','泥')

str.replace('妮','泥',0) 第一位的

##### 字符串的特点

python 与 java 一样,原定义的字符串是不允许修改的

比如 my_str = 'abcd'

my_str[0] = 'Q' 报错.不可以赋值修改

#### 元组

##### 不可修改的列表

列表用中括号[]

**元组用小括号**

(10,20,30,40)

> 注意:元组中如果只有1个元素的话,需要在元素后加逗号

元组可以嵌套元组,如:((1,2),(10,20))

元组中的元素不能修改

#### 列表

列表属于序列式容器,支持索引,切片

**对于列表而言,尾部插入数据的效率要高一些,不需要移动元素,指定位置插入效率较低**

位置删除在尾部删除效率比较高,不需要移动元素

列表支持:位置删除(尾部删除,指定位置删除)值删除

缺点:根据关键字查找效率低

列表根据索引查找效率很高

```python
my_list=[[1,2,3,],[4,5,6],[1,2,3]]
my_list=['Trump',60,3.14,[1,2,3]]
print(my_list[:2])
#append 在列表尾部追加插入元素
my_list.append(10)
#insert 在指定位置插入元素
my_list.insert(0,100) #0位置插入值100
#pop 删除指定位置元素,默认删除最后一个位置元素
my_list.pop()
my_list.pop(1)
#remove 移除 根据值删除
my_list.remove(200)
#clear 清除清空列表数据
my_list.clear()
#sort 对列表进行排序,默认是从小到大
my_list.sort()
my_list.sort(reverse=True) #将函数的 reverse 的默认值改成True 即可实现从大到小
#reverse 将列表按照原有顺序逆序排序,颠倒
my_list.reverse()
#extend 将一个列表中的所有元素追加到当前列表的尾部
my_list.extend(list)
#判断元素是否存在列表中:
if a in list:
```

#### 字典

查找快,但占空间

**大括号**

```python
语法:
my_dict = {key:value,key2:value2}
```

**字典属于非序列式容器,占内存,但是是效率高,属于空间换时间**

注意:键一般是唯一的,如果最后的重新赋值会覆盖前面

```python
persion={'name':'张三','age':20,'sex':'男',100:101}
# 如果 key 不存在会报错
print(person['name'])
# 如果 key 不存在可以设置默认值
print(persion.get('gender','default'))
# 添加元素 存在替换,不存在更新
persion['school']='123'
# del 删除元素 
del person['age'] #将对应键的"键和值"都删除
# 清空字典
person.clear()
# 默认只能遍历出来键
for val in my_dict:
    print(val)
# 遍历
my_dict = {'aaa':10,'ccc':30,'bbb':20}
key_list = my_dict.keys()
['aaa','ccc','bbb']
value_list = my_dict.values()
[10,30,20]
key_value_list = my_dict.items()
[('aaa',10),('ccc',30),('bbb',20)]
```

##### 字符中的 \t 代表 Tab 键

#### 文件

二进制模式和文本模式

在python,使用open函数,可以打开一个已经存在的文件,或者创建一个新文件,使用close 方法来关闭一个文件

1. 什么是文件 ,文件的作用就是计算机存储数据
2. 如何打开关闭文件
3. 文件打开模式的区别
4. 如何在程序中进行文件读写
5. 知道文件,目录管理操作

在python ,使用open 函数,可以打开一个已经存在的文件,或者创建一个文件

```python
#打开文件
f = open('text.txt,'w) # 返回文件对象
#关闭文件
f.close 
# 写入文件
f.write("1231232131\n")
```

![1563262056016](C:\Users\89463\AppData\Roaming\Typora\typora-user-images\1563262056016.png)

**文本模式和二进制模式的区别**

##### 打开文件用的文本模式,会进行换行符的转换:

> 程序:hello world\n
>
> ->windows hello world\r\n
>
> ->mac hello world \r
>
> ->linux hellow world\n
>
> 如果使用二进制模式不会转换

##### 2.读取文件数据

```python
f = open('b.txt','r')
mycontent = f.read()
f.close()
print(mycontent)
```

##### 3.文件读写方法

##### writelines

```python
f = open('b.txt','r')
mycontent = f.read()
f.close()
print(mycontent)
```

##### 文件拷贝

#### 文件操作 os 模块

1. 知道如何删除文件

2. 知道如何获得文件名列表

3. 知道重命名文件

4. 知道如何创建和删除文件

   **批量操作等**

文件操作相关模块

```python
import os
#改名:
os.rename('11[附件].html','index.html')
#创建目录:
os.mkdir('abc')
#删除目录:
os.rmdir('abc')
#获得指定目录下的文件列表:
os.listdir()
#获得和设置工作目录 默认为当前工程.py文件的目录路径:
os.getcwd()
```

```
#当前文件的路径
pwd ``=` `os.getcwd()
#当前文件的父路径
father_path``=``os.path.abspath(os.path.dirname(pwd)``+``os.path.sep``+``"."``)
#当前文件的前两级目录
grader_father``=``os.path.abspath(os.path.dirname(pwd)``+``os.path.sep``+``".."``)
```

# Python 加强

![1567074451622](C:\Users\89463\AppData\Roaming\Typora\typora-user-images\1567074451622.png)

**计算机不能直接理解任何机器语言以外的语言**，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。**将其他语言翻译成机器语言的工具，被称为编译器**。

编译器翻译的方式有两种：一个是**编译**，另外一个是**解释**。两种方式之间的区别在于**翻译时间点的不同**。当编译器以解释方式运行的时候,也称之为解释器。

- **编译型语言：** 程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性稍差。如C，C++
- **解释型语言：**解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行。

**编译型语言和解释型语言对比**

- 速度 -- 编译型语言比解释型语言执行速度快
- 跨平台性 -- 解释型语言比编译型语言跨平台性好

**设计目标：**

- 简单，直观，强大
- 开源
- 容易理解
- 适合短期开发等日常任务

### Python 设计哲学

优雅、明确、简单

- Python 开发者的哲学是，用一种方法，最好是只有一种方法来做一件事
- 如果面临多种选择，Python 开发者一般会拒绝花俏，而选择明确而没有或很少歧义的语法

> 在 Python 社区，吉多被称为“仁慈的独裁者”

### Python 特点

- Python 是**完全面向对象的语言**
  - **函数、模块、数字、字符串**都是对象，在 **Python 中一切皆对象**
  - 完全支持继承、重载、多重继承
  - 支持重载运算符、也支持泛型设计
- Python **拥有一个强大的标准库**，Python 语言的核心只包含 **数字、字符串、列表、字典、文件** 等常见类型和函数，而由 Python 标准库提供了 **系统管理、网络通信、文本处理、数据库接口，图形处理、XML 处理**等额外的功能。
- Python 社区提供了大量的第三方模块，使用方式与标准库类似。它们的功能覆盖了 科学计算、人工智能、机器学习、Web 开发、数据库接口、图形系统多个领域

**缺点：**（部分暂时的）

- 运行速度
- 国内市场小？？
- 中文资料匮乏？？

### 错误类型

- NameError ：函数名称错误
- SyntaxError：语法错误
- IndentationError:  缩进错误

### Python 2.x /3.x

- Python 2.x 是过去版本，默认不支持中文

> - ASCII 字符只包含 256 个字符，不支持中文
> - 有关字符编码的问题，后续会讲

- Python 3.x 现在和未来的主流版本

  - 没有考虑向下兼容
  - Python 3.0 发布于 2008 年
  - Python 3.0 的稳定版本已经有很多年
    - Python 3.3 发布于2012
    - Python 3.4 发布于2014
    - Python 3.5 发布于2015
    - Python 3.6 发布于2016

- 为了照顾现有的程序，官方提供了一个过度版本 -- Python 2.6

  - 基本使用了 Python 2.x 的语法和库
  - 同时考虑了向 Python 3.0 的迁移，允许使用部分 Python 3.0 的语法和函数
  - 2010 年中推出的 Python 2.7 被确定为最后一个 Python 2.x 版本

  > 提示：如果开发时，无法立即使用 Python 3.0 （还有极少的第三方库不支持3.0 语法），建议
  >
  > - 先使用 Python 3.0 版本进行开发
  > - 然后使用 Python 2.6、Python 2.7 来执行，并且做一些兼容性的处理

### Python 的解释器

- CPython -- 官方版本官方发布的 C 语言实现的
- JPython -- 可以运行在Java 平台
- IronPython -- 可以运行在 .NET 和 Mono 平台
- PyPy -- Python 实现的，支持 JIT 即时编译

#### 两种运行 Python 的方式

- 交互式运行 Python 程序
  - 直接在终端中运行
    - 在Python Shell 中输入
- 优点
  - 验证局部代码/适合学习
- 缺点
  - 代码不能保存
  - 不适合运行太大的程序
- ctrl+d 退出

#### IPython 交互式 interactive

**特点**

- IPython 是一个 python 的交互式 shell，比默认好用
  - 支持自动补全
  - 自动缩进
  - 支持 bash shell 命令
  - 内置了许多 很有用的功能和函数
- 基于 BSD 开源

版本

- Python 2.x 使用的解释器是 ipython 
- Python 3.x 使用的解释器是 ipython3
- 退出方式 exit or ctrl +d

## Python IDE -- PyCharm

- 图形用户界面
- 代码编译器
- 编译器/解释器
- 调试器（断点/单步执行）

PyCharm 介绍

- PyCharm 适合开发大型项目
  - 一个项目通常包含很多源文件
  - 每个源文件行数有限
  - 每个源文件各司其职

PyCharm 初始设置

PyCharm 配置信息保存在用户家目录下的 .PyCharmxxx.x 目录下的，xxxx.x 表示当前使用的版本号

如果要恢复 PyCharm 的初始设置，可以按照以下步骤执行：

- 关闭正在运行的 P有charm
- 终端执行以下命令

```
rm -r ~/.PyCharm2016.3
```

- 重启 PyCharm



#### 设置项目使用的解释器版本 

File/Settings... Project Interproter

#### 命名规则

1. 命名文件时建议只使用小写字母，数字和下划线
2. 文件名不能以数字开始

#### PyCharm 的升级和其他

安装步骤：

tar -zxvf pycharm-xxxxxxxx.tar.gz

移动到 /opt 目录下，方面其他用户使用

sudo mv xxxx /opt/

切换工作目录

启动

> ubuntu 中，应用程序启动的快捷方式通常保存在 /usr/share/applications 目录下

#### PyCharm 卸载





### Python 代码规范

- python.org
- 谷歌中文文档

> 正规开发团队，需要有代码审核的惯例

 CPU 

- 超大规模集成电路

- 负责 处理数据/计算

一般程序执行原理：

![1567078136314](C:\Users\89463\AppData\Roaming\Typora\typora-user-images\1567078136314.png)

1. 程序运行之前，保存在硬盘中
2. 需要运行程序时
   - 操作系统会首先让CPU 把程序复制到内存中
   - CPU 执行内存中的程序代码

> 程序要执行，首先要被加载到内存

#### Python 程序执行原理

![1567078116230](C:\Users\89463\AppData\Roaming\Typora\typora-user-images\1567078116230.png)

1. 操作系统会首先让CPU 把 Python 解释器的程序复制到内存中
2. Python 解释器根据语法规则，从上向下，让CPU 翻译 Python 程序中的代码
3. CPU 负责执行翻译完成的代码

## Python 变量类型

数据类型 ：数字型、非数字型

- 数字型
  - 整型（int）
  - 浮点型（float）
  - bool
  - 复数 complex
    - 主要用于科学计算，，例如平面场问题，波动问题，电感电容问题
- 非数字型
  - 字符串
  - 列表
  - 元组
  - 字典

##### type 函数 可以查看变量类型

> Python 2.x 中，整数根据保存数值的长度还分为：
>
> - int 整数
> - long 长整数

- 使用 type 函数可以查看一个变量的类型

##### 字符串拼接：

- `+`
- `*`倍数

字符串和数字之间不能计算

##### 1） 基本函数

- input() 输入
- type() 查看变量类型

##### 2) 类型转换函数

- `int(x)` 将x 转换为整数
- `float(x)` 

#### 变量的格式化输出

- `%s` 字符串
- `%d` 有符号十进制整数，`%06d` 表示输出的整数显示位数，不足的地方使用0 补全
- `%f` 浮点数，`%.02f` 表示小数点后只显示两位
- `%%` 输出 %

#### 关键字

查看python 中的关键字

```
import keyword 
print(keyword.kwlist)
```

- import 关键字可以导入一个工具包

#### 变量的命名规则

> 命名规则 可以被视为一种管理，并无绝对与强制，目的时为了增加代码的识别和可读性

注意 Python 中的 标识符 是区分大小写的

- 在Python 中，如果变量名，需要由二个或多个单词组成时，可以按照y以下方式命名
  - 每个单词都使用小写字母
  - 单词与单词之间使用 `_` 下划线链接
  - 列入 first_name....

#### 程序的三大流程

- 顺序--从上向下，顺序执行代码
- 分支--根据条件判断，决定执行代码的分支
- 循环 -- 让特定代码重复执行

#### 转义符

- `\t` 对齐
- `\r` 回车
- `\n` 换行
- `\\`反斜杠

- `\'`
- `\"`



### 函数

格式：

```
def 函数名():
	函数体
	...
```

- def 是英文 defince 的缩写
  - 字母、下划线 和 数字组成
  - 不能以数字开头
  - 不能与关键字重名

#### 形参和实参

- **形参：**定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用
- **实参：**调用函数时，小括号中的参数，是用来把数据传递到 函数内部用 的。

![1567081149827](C:\Users\89463\AppData\Roaming\Typora\typora-user-images\1567081149827.png)



## 模块

> 模块是 Python 程序架构的一个核心概念

- 模块 久好比是工具包，要想使用这个工具包中的工具，就需要导入import 这个模块
- 每一个以扩展名 py 结尾的 Python 源代码文件都是一个模块
- 在模块中定义的全局变量、函数 都是模块能够提供给外界直接使用的工具

小结

- 可以**在一个Python 文件中** 定义**变量**或者**函数**，然后再**另一个文件中**使用import 导入这个模块
- 导入之后，就可以使用 模块名.变量/模块名.函数 的方式，使用这个模块中d定义的变量或者函数

> **模块**可以让**曾经写过的代码**方便的被**复用**

#### 模块名也是一个标识符

- 标识符可以由 **字母**、**下划线**和**数字**组成
- **不能以数字开头**
- **不能与关键字重名**

> 注意：PyCharm 无法导入 ，数字开头的 python 文件

#### Pyc 文件

> C 是 compiled **编译过** 的意思

**操作步骤**

1. 浏览程序目录会发现一个 `__pycache__`的目录

2. 目录下有个 `hmxxxxx.cpython-35.pyc`文件, cpython-35 表示版本

3. 这个pyc 文件是由 Python 解释器 将模块的源码转换为 字节码

   - Python 这样保存字节码是作为一种启动速度的优化

**字节码**

- python 再解释源程序时是分成两个步骤的
  1. 首先处理源代码，**编译**生成一个二进制字节码
  2. 再对**字节码**进行处理，才会生成CPU 能够识别的**机器码**
- 有了模块的字节码文件之后，下一次运行程序时，如果在s上次保存字节码之后没有修改过源码，Python 将会加载 `.pyc` 文件并跳过编译
- 当 Python 重新编译时，它会检查源文件和字节码文件的时间戳
- 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建

### 高级变量类型

> 列表（数组）、元组、字典

#### 列表

- List 

> **索引** 就是数据在 **列表**中的位置编号，**索引** 又可以被称为 **下标**

**列表的常用操作**

![1567082424364](C:\Users\89463\AppData\Roaming\Typora\typora-user-images\1567082424364.png)

| 函数名                          | 释义                              |
| ------------------------------- | --------------------------------- |
| 列表.append(数据)               | 末尾追加数据                      |
| 列表.count(数据)                | 数据在列表中出现的次数            |
| 列表.insert(索引，数据)         | 在指定位置插入数据                |
| 列表.reverse()                  | 反转/逆序                         |
| 列表.clear()                    | 清空                              |
| 列表.extend(列表2)              | 将列表2的数据追加到列表1          |
| 列表.del(索引)                  | 删除指定索引位置                  |
| 列表.pop()/pop(索引)            | 删除列表末尾数据/删除指定索引位置 |
| 列表.sort ()/sort(reverse=True) | 默认升序排序/降序排序             |
| 列表.copy()                     | 复制                              |
| 列表.index(数据)                | 获得数据第一次出现的索引          |
| 列表.remove(数据)               | 删除第一个出现的指定数据          |
| 列表.len()                      | 获取列表的长度                    |

#### List 循环遍历

- 有专门提供的**迭代 itertion 遍历**

- 在Python，可以使用 for 循环遍历所有非数字类型的变量

### 元组 

- Tuple 元组 ，定义后 元组不能修改
- tuple = ()

### 字典

- 键 key 索引
- `: `分隔
- 键必须唯一
- 无序的数据集合

常用函数：

| 函数                | 释义                                     |
| ------------------- | ---------------------------------------- |
| clear()             | 清空键值对                               |
| copy                |                                          |
| fromkeys()          |                                          |
| get                 |                                          |
| items               |                                          |
| keys                |                                          |
| pop                 |                                          |
| popitem             |                                          |
| setdefault          |                                          |
| 字典1.update(字典2) | 合并字典，如果已经存在键值对，会进行覆盖 |
| values              |                                          |
| 字典.len()          | 键值对数量                               |

#### 字典循环遍历

```python
dict1 = {"name":"xiaoming","gender":"male","age":"20"}
for k in dict1:
    print("%s:--%s"%(k,dict1(k)))

# 打印结果 无序的
```

> 提示：实际开发中，由于字典中每一个键值对保存数据的类型不同，所以针对字典的循环遍历需求不多

- 尽管可以使用 `for in  ` 遍历字典
- 但是在开发中，更多的场景是
  - 使用 **多个键值对**，存储**描述一个对象物体**的**相关信息** -- 描述更复杂的数据信息
  - 将 **多个字典** 放在 **一个列表** 中，再进行遍历，在循环体内部针对每一个字典进行 **相同的处理**

### 字符串

常用函数：

- `len(字符串)` ：获取字符串长度
- `字符串.count(字符串)`：小字符串在大字符串中出现的次数
- `字符串.index(子字符串)`：查询某个子字符串出现的位置。**注意**，如果子字符串**不存在**，程序会报错，**ValueError**

1

| 函数       | 释义 |
| ---------- | ---- |
| maketrans  |      |
| casefold   |      |
| center     |      |
| count      |      |
| encode     |      |
| expandtabs |      |
| format     |      |
| format_map |      |
| partition  |      |

**判断**

| 函数          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| isspace()     | 如果string 中只包含空格，则返回True                          |
| isalnum()     | 如果 string 至少有一个字符并且所有字符都是字符或数字则返回True |
| iaalpha()     | 如果 string 至少有一个字符并且所有字符都是字母，则返回True   |
| islower()     | 如果string 中包含至少一个区分大小写的字符，并且所有这些字符都是小写，则返回True。 |
| isdecimal()   | 如果 string 只包含数字则返回True,全角数字                    |
| isdigit()     | 如果 string 只包含数字则返回True,全角数字、(1)\\u00b2        |
| isnumeric()   | 如果string 只包含数字则返回True,全角数字，汉字数字           |
| isupper()     | 如果string 中至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是大写，则返回True |
| istitle()     | 如果string 时标题化的，每个单词的首字母大写，则返回True      |
| isidentifier  |                                                              |
| isprintable() |                                                              |

**查找和替换**

| 函数                                                 | 说明                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| startswith(str)                                      | 检查字符串是否以 str 开头，是则返回True                      |
| endswith(str)                                        | 检查字符串是否以 str 结束，是则返回True                      |
| find(str,start=0,end=len(string))                    | 检测，str 是否包含在string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 |
| rfind(str,start=0,end=len(string))                   | 类似find,但从右边查找                                        |
| index(str,start=0,end=len(string))                   | 类似find(),只不过 str 找不到会报错                           |
| rindex(str,start=0,end=len(string))                  | 类似index,但从右边开始                                       |
| replace(old_str,new_str,<br />num=string.count(old)) | 把string 中的 old_str替换成new_str，如果num ，指定则替换不超过num 次？ |

**大小写转换**

| 函数        | 说明                             |
| ----------- | -------------------------------- |
| captalize() | 把字符串的第一个字符大写         |
| title()     | 把字符串的每个单词首字母大写     |
| lower()     | 转换 string 中所有大写字符为小写 |
| upper()     | z转换string 中的小写字母为大写   |
| swapcase()  | 反转string 中的大小写            |

**文本对齐**

| 函数          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| ljust(width)  | 返回一个原字符串左对齐,并使用空格填充长度 width 的新字符串   |
| rjust(width)  | 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 |
| center(width) | 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串   |

**去除空白字符**

| 函数     | 说明                                    |
| -------- | --------------------------------------- |
| lstrip() | 截掉 string 左边(开始) 的空白字符       |
| rstrip() | 截掉 string 右边(末尾) 的空白字符       |
| strip()  | 截掉 string 左右两边的空白字符,返回列表 |

**拆分和连接**

| 函数              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| partition(str)    | 把字符串string 分成一个3 元素的元组(str 前面,str,str 后面)   |
| rpatition(str)    | 类似于 partition() 函数,不过是从右边开始查找                 |
| split(str="",num) | 以str 为分隔符切片 string,如果 num 有指定值,则仅分隔 num +1 个子字符串,str 默认包含`\r`,`\t`,`\n`和空格 |
| splitlines()      | 按照行(`\r`,`\n`,`\r\n`)分隔,返回一个包含各行作为元素的列表  |
| string.join(seq)  | 以string 作为分隔符,将 seq 中所有的元素合并为一个新的字符串  |

#### 字符串的切片

- 格式
  - `字符串[开始索引:结束索引:步长]`，（步长默认为1）

- **切片** 适用于 **字符串、列表、元组**。不适用(字典:无序)

```
num_str = "0123456789"
1.截取从 2~5 位字符串
num_str[2:6]
2.截取 2~末尾的字符串
num_str[2:]
3.每隔一个字符截取字符串
num_str[::2]
4.索引从1开始，每隔一个截取字符串
num_str[1::2]
5.截取从2~末尾-1的字符串
num_str[2:-1]
6.截取字符串末尾两个字符
num_str[-2:]
7.字符串的逆序
num_str[-1::-1]或
8.如何截取97531
num_str[-1::-2]或num_str[::-2]
```

### Python 公共函数方法

| 函数             | 描述               | 备注                      |
| ---------------- | ------------------ | ------------------------- |
| len(item)        | 计算容器中元素个数 |                           |
| del(item)        | 删除变量           |                           |
| max(item)        |                    |                           |
| min(item)        |                    |                           |
| cmp(item1,item2) | 比较两个值         | Python 3.x 取消了cmp 函数 |

#### 运算符

| 运算符            | 表达式           | 结果                      | 描述           | 支持的数据类型           |
| ----------------- | ---------------- | ------------------------- | -------------- | ------------------------ |
| +                 | [1,2]+[3,4]      | [1,2,3,4]                 | 合并           | 字符串、列表、元组       |
| *                 | ['Hi!']*4        | ['Hi!','Hi!','Hi!','Hi!'] | 重复           | 字符串、列表、元组       |
| in                | 3 in(1,2,3)      | True                      | 元素是否存在   | 字符串、列表、元组、字典 |
| not in            | 4 not in (1,2,3) | True                      | 元素是否不存在 | 字符串、列表、元组、字典 |
| `>` `>=` `==`.... |                  |                           | 元素比较       | 字符串、列表、元组       |



#### 成员运算符

- `in `
- `not in` 
- 注意：在对字典操作时，判断的是字典的键

#### 完整的for 循环

```python
for num in [1,2,3]
	print(num)
    if num ==2:
        break
else:
    print("2")
print('结束')
```



## 变量进阶

- 变量的引用
- 可变和不可变类型
- 局部变量和全局变量

#### 变量的应用

- 变量和数据都是保存在内存中的
- 在 Python 中的函数的参数传递以及返回值都是靠引用传递的

#### 引用的概念

在 Python 中

- **变量** 和 **数据**是分开存储的
- **数据**保存在内存中的一个位置
- **变量**中保存着数据在内存中的地址
- **变量**中**记录数据的地址**，就叫做**引用**
- 使用 id() 函数可以查看变量中保存数据所在的**内存地址**

> 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是**修改了数据的引用**
>
> - 变量 **不再** 对之前的数据引用
> - 变量 **改为** 对新赋值的数据引用

#### 可变和不可变类型

- **不可变类型**，内存中的数据不允许被修改：
  - 数字类型 int，bool，float，complex，long(2.x)
  - 字符串 str
  - 元组 tuple
- **可变类型**，内存中的数据可以被修改：
  - 列表 list
  - 字典 dict

> 注意：字典的 key 只能使用不可变类型的数据，包括元组

**注意**：

1. 可变类型的数据变化，是通过方法来实现的
2. 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改
   - 变量 **不再** 对之前的数据引用
   - 变量 **改为** 对新赋值的数据引用

> 使用`id(变量)`可查看引用的内存地址

#### 哈希 Hash

- Python 内置了一个 `hash(o)`函数
  - 接收一个**不可变类型**的数据作为**参数**
  - **返回** 结果是一个 **整数**
- 哈希 是一种**算法**，其作用就是提取数据的 **特征码（指纹）**
  - **相同的内容** 得到 **相同的结果**
  - **不同的内容** 得到 **不同的结果**
- 在 Python 中，设置字典的 键值对 时，会首先对 `key` 进行 `hash` 已决定如何在内存中保存字典的数据，以方便**后续**对字典的操作：**增删改查**
  - key 必须时不可变类型数据
  - value 可以是任意类型的数据

#### 局部变量和全局变量

- 以函数作为基准
- 局部变量，函数内部定义的变量，只能在内部使用
- 全局变量，函数外部定义的变量，所有函数内部都能使用

#### 局部变量

- 函数内部定义的变量，只能函数内部使用
- 函数执行结束后，函数内部的局部变量，会被系统回收

##### 局部变量的生命周期

- 变量 **创建** 到 **被回收** 的过程
- **局部变量** 在 **函数执行时** 才会被创建
- **函数执行结束后**，局部变量 **被系统回收**
- 局部变量在生命周期内，可以用来存储 **函数内部临时使用到的数据**

**局部变量的作用**

- 在函数内部使用，临时保存 函数内部需要使用的数据

#### 全局变量

注意：函数执行时，需要处理变量时 会

1. 首先 查找 函数内部 是否存在 指定名称的局部变量，如果有，直接使用
2. 再查外部全局变量
3. 如果没有报错

**1）函数不能直接修改全局变量的引用**

- 函数外部定义，所有函数都能使用
- 不允许直接修改全局变量的引用-- 使用赋值语句修改全局变量的值

**2）函数内部修改全局变量的值 global ** 

- 使用 `global` 修饰
-  `global num`

> 全局变量，变量要定义在所有语句上方，解释器解释代码逐条解释

**代码结构示意图**

1. shebang
2. import 模块
3. 全局变量
4. 函数定义
5. 执行代码

##### 全局变量命名建议

- 全局变量变量命名前增加 `g_` 或者 `gl_` 的前缀

## 函数

### 01 函数参数和返回值作用

- 函数返回值 进阶
- 函数 参数进阶
- 递归函数

### 02 函数的返回值 进阶

- 返回元组
- 接收根据角标取值

**面试题-交换两个数字**

- 解法1 -- 使用其他变量

- 解法2 -- 不使用临时变量

  ```
  a=a+b
  b=a-b
  a=a-b
  ```

- **解法3 -- Python 专有--元组**

  ```
  a,b = (b,a)
  可省略小括号
  a,b = b,a
  ```

### 03 函数的参数进阶

#### 3.1 不可变和可变的参数 （重要）

> 问题1- 在函数内部，针对参数使用 赋值语句，是不会影响调用函数时传递的 实参变量-- 不会

- 无论传递的参数是 **可变** 还是 **不可变参数**
  - 只要 **针对参数** 使用 **赋值语句**，会在**函数内部**修改**局部变量的引用**，**不会影响到外部变量的引用**

比如：

```python
def demo(arg1,arg2):
	arg1 = 1 #内存重新创建了一个新内存地址，替换了这里的参数变量地址
    arg2 = [1,2,3] #此内部参数被替换了引用地址
	print(arg1)
    print(arg2)

a = 2
b = [1,2]
demo(a,b)
print(a)#仍然指向原地址，原地址内容没有改变，
print(b)
```

> 问题2： 如果传递的实参是 **可变类型** ，在函数内部，使用 方法 修改了数据的内容，**同样会影响到外部的数据**

例：

```python
def demo(list):
	list.extend([1,2])#不会替换引用，针对原地址数据，直接修改数据内容
    print(list)

list = [1,2,3]
demo(list)
print(list)#list 变量被改变
```

##### 面试题 -- 关于 `+=`

- 在 python  中，列表变量调用 `+=` 本质上是在执行列表变量的 `extend` 方法，不会修改变量的引用

```python
def demo(num,num_list):
	num += num # num = num + num 
    num_list += num_list #不同于数字相加变量，实际上是num_list.extend(num_list)
    print(num)
    print(num_list)

num = 9 #字符串也一样
num_list = {num_list}
demo(num,num_list)
print('num=',num)
print('num_list=',num_list)
```

#### 缺省参数

- 定义函数时，可以给 **某个参数** 指定一个**默认值**，具有默认值的参数就叫做 **缺省参数**
- 调用函数时，如果没有传入 **缺省参数** 的值，则在函数内部使用定义函数时指定的 **参数默认值**
- 函数的缺省参数，**将常见的值设置为参数的缺省值**，从而简化函数的调用
- 例如：对列表排序的方法 `list.sort(reverse=True)`

```
def demo(name,age='20'):
	...
```

**缺省参数的注意事项**

- 必须保证带有默认值的缺省参数 在参数列表**末尾**

  ```
  错误的：
  def demo(a,b='1',c):
  	...
  ```

#### 多值参数

**定义支持多值参数的函数**

- **一个函数**能够处理的**参数个数时不确定的**，这个时候，就可以使用多值参数
- python 中有 两种多值参数:
  - 参数名前增加 **一个** `*` 可以接收**元组**
  - 参数名前增加**两个**（`**`），可以接收 **字典**

- 一般在给多值参数命名时，习惯使用以下两个名字
  - `*args` -- 存放 **元组** 参数，前面有一个。
  - `**kwargs`-- 存放 **字典** 参数，前面有两个。
- args 时 arguments 的缩写
- kw 是 keyword 缩写，kwargs 可以记忆键值对参数

##### 元组和字典的拆包

-  在调用带有多值参数的函数时候，如果希望
  - 将一个元组变量，直接传递



```python
def demo(*arg,*kwargs):
    print(args)
    print(kwargs)

g_nums=(1,2,3)
g_dict={"name":"小明","age":18}
demo(g_num,g_dict)
# 打印结果导致，两个变量都传入了 *args,另外的没有用到
# ((1,2,3),{'age':18,'name':'小明'})

# 解决：使用拆包语法：
demo(*g_num,**g_dict)
# 另一种方式--不使用拆包语法：
demo(1,2,3,name='小明',age=19)
```

### 函数的递归

> 函数调用自身的**编程技巧** 称为递归

#### 递归函数特点

- 函数内部调用自己
- 函数内部代码相同，只是参数不同，处理的结果不同
- 当参数满足一个条件时，函数不再执行
  - 这个非常重要，通常被称为递归的出口，否则会出现死循环

```python
def demo(num):
    print(num)
    #递归出口
    if num == 1:
        return
    demo(num-1)

demo(3)
```

**执行顺序**：

![1567155787037](C:\Users\89463\AppData\Roaming\Typora\typora-user-images\1567155787037.png)

1